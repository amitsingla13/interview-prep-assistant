<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="AI-powered interview preparation and language practice assistant">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Interview Prep">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <title>Interview Preparation Assistant</title>
    <!-- PWA -->
    <link rel="manifest" href="/static/manifest.json">
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <link rel="apple-touch-icon" sizes="192x192" href="/static/icons/icon-192x192.png">
    <link rel="apple-touch-icon" sizes="512x512" href="/static/icons/icon-512x512.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .container {
            width: 100%;
            max-width: 600px;
            height: 100vh;
            max-height: 100vh;
            background: #fff;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        @media (min-height: 700px) and (min-width: 640px) {
            .container {
                height: 95vh;
                max-height: 95vh;
                border-radius: 20px;
                box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            }
        }
        @media (max-width: 639px) {
            .container {
                max-width: 100%;
                border-radius: 0;
            }
        }
        .header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 20px;
            text-align: center;
            flex-shrink: 0;
        }
        .header h1 { font-size: 20px; margin-bottom: 3px; }
        .header p { font-size: 12px; opacity: 0.85; }
        .mode-buttons {
            display: flex;
            gap: 8px;
            padding: 12px 15px;
            justify-content: center;
            flex-wrap: wrap;
            flex-shrink: 0;
        }
        .mode-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
        }
        .mode-btn.interview { background: #007bff; }
        .mode-btn.interview:hover { background: #0056b3; }
        .mode-btn.language { background: #28a745; }
        .mode-btn.language:hover { background: #1e7e34; }
        .mode-btn.helpdesk { background: #17a2b8; }
        .mode-btn.helpdesk:hover { background: #117a8b; }
        .mode-btn.reset { background: #dc3545; font-size: 12px; padding: 8px 15px; }
        .mode-btn.reset:hover { background: #c82333; }

        #language-picker {
            display: none;
            padding: 0 20px 15px;
            text-align: center;
        }
        #language-picker select {
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid #28a745;
            font-size: 14px;
            margin-right: 10px;
        }
        #language-picker button {
            padding: 10px 20px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
        }

        .chat-area {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            padding: 15px;
            background: #f8f9fa;
        }
        .message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }
        .message.bot { justify-content: flex-start; }
        .message.user { justify-content: flex-end; }
        .message .avatar {
            width: 36px; height: 36px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 16px; color: white; flex-shrink: 0;
        }
        .message.bot .avatar { background: #667eea; }
        .message.user .avatar { background: #28a745; }
        .bubble {
            max-width: 75%;
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 14px;
            line-height: 1.5;
        }
        .message.bot .bubble {
            background: white;
            color: #333;
            border-bottom-left-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .message.user .bubble {
            background: #007bff;
            color: white;
            border-bottom-right-radius: 4px;
        }
        .message .audio-player {
            margin-top: 8px;
        }
        .message .audio-player audio {
            height: 32px;
            width: 100%;
        }

        .input-area {
            display: flex;
            padding: 10px 15px;
            gap: 8px;
            border-top: 1px solid #eee;
            background: white;
            align-items: center;
            flex-shrink: 0;
        }
        .input-area input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 25px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.3s;
        }
        .input-area input:focus { border-color: #667eea; }
        .send-btn {
            width: 44px; height: 44px;
            border-radius: 50%;
            border: none;
            background: #007bff;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .send-btn:hover { background: #0056b3; }
        .mic-btn {
            width: 50px; height: 50px;
            border-radius: 50%;
            border: none;
            background: #dc3545;
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .mic-btn.recording {
            background: #28a745;
            animation: pulse 1s infinite;
            box-shadow: 0 0 20px rgba(40,167,69,0.5);
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); }
        }
        .status-bar {
            text-align: center;
            padding: 5px;
            font-size: 11px;
            color: #666;
            background: #f0f0f0;
            flex-shrink: 0;
        }
        .typing-indicator {
            display: none;
            padding: 10px 20px;
            color: #999;
            font-size: 13px;
            font-style: italic;
        }
        /* Voice/Text toggle */
        .voice-toggle-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 15px;
            flex-shrink: 0;
            background: #f0f0f0;
            border-top: 1px solid #e0e0e0;
        }
        .voice-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #555;
        }
        .voice-toggle label {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .toggle-switch {
            position: relative;
            width: 42px;
            height: 22px;
            display: inline-block;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 22px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }
        .toggle-switch input:checked + .toggle-slider {
            background-color: #28a745;
        }
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }
        .session-timer {
            font-size: 12px;
            color: #888;
            font-family: monospace;
        }
        /* Play button for on-demand TTS */
        .play-tts-btn {
            background: none;
            border: 1px solid #667eea;
            color: #667eea;
            border-radius: 15px;
            padding: 4px 10px;
            font-size: 12px;
            cursor: pointer;
            margin-top: 5px;
            transition: all 0.2s;
        }
        .play-tts-btn:hover {
            background: #667eea;
            color: white;
        }
        .play-tts-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .play-tts-btn i {
            margin-right: 4px;
        }
        .cost-badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 8px;
            margin-left: 6px;
        }
        .cost-badge.saving { background: #d4edda; color: #155724; }
        .cost-badge.active { background: #fff3cd; color: #856404; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-headset"></i> Interview Prep Assistant</h1>
            <p>Practice interviews, language speaking & IT support with AI</p>
        </div>

        <div class="mode-buttons">
            <button class="mode-btn interview" onclick="startInterview()">
                <i class="fas fa-briefcase"></i> Interview Assistant
            </button>
            <button class="mode-btn language" onclick="showLanguagePicker()">
                <i class="fas fa-language"></i> Language Practice
            </button>
            <button class="mode-btn helpdesk" onclick="startHelpdesk()">
                <i class="fas fa-headset"></i> IT Helpdesk
            </button>
            <button class="mode-btn reset" onclick="resetSession()">
                <i class="fas fa-redo"></i> Reset
            </button>
        </div>

        <div id="language-picker">
            <select id="lang-select">
                <option value="en">English</option>
                <option value="es">Spanish</option>
                <option value="fr">French</option>
                <option value="de">German</option>
                <option value="zh">Chinese</option>
                <option value="hi">Hindi</option>
                <option value="ja">Japanese</option>
                <option value="ko">Korean</option>
                <option value="pt">Portuguese</option>
                <option value="ar">Arabic</option>
                <option value="ru">Russian</option>
                <option value="it">Italian</option>
                <option value="nl">Dutch</option>
            </select>
            <button onclick="startLanguageTest()">Start</button>
        </div>

        <div class="chat-area" id="chat-area"></div>
        <div class="typing-indicator" id="typing">
            <i class="fas fa-circle-notch fa-spin"></i> Bot is thinking...
        </div>
        <div class="status-bar" id="status">Choose a mode to start</div>

        <div class="voice-toggle-bar">
            <div class="voice-toggle">
                <label>
                    <i class="fas fa-keyboard" id="mode-icon-text"></i>
                    <span class="toggle-switch">
                        <input type="checkbox" id="voice-toggle" onchange="toggleVoiceMode()">
                        <span class="toggle-slider"></span>
                    </span>
                    <i class="fas fa-volume-up" id="mode-icon-voice"></i>
                    <span id="voice-mode-label">Text mode</span>
                    <span class="cost-badge saving" id="cost-badge">$$$ saving</span>
                </label>
            </div>
            <div class="session-timer" id="session-timer">00:00</div>
        </div>

        <div class="input-area">
            <input type="text" id="text-input" placeholder="Type a message..." maxlength="2000" onkeypress="if(event.key==='Enter')sendText()">
            <button class="send-btn" onclick="sendText()" title="Send text">
                <i class="fas fa-paper-plane"></i>
            </button>
            <button class="mic-btn" id="mic-btn" onclick="toggleRecording()" title="Click to start listening â€“ auto-detects when you stop talking">
                <i class="fas fa-microphone"></i>
            </button>
        </div>

        <div style="text-align:center; padding:6px; font-size:11px; color:#999; background:#fff; flex-shrink:0; border-top:1px solid #eee;" class="footer-links">
            <a href="/privacy" style="color:#888; text-decoration:none; margin:0 8px;">Privacy Policy</a>
            <span style="color:#ccc;">|</span>
            <a href="/terms" style="color:#888; text-decoration:none; margin:0 8px;">Terms of Service</a>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.4/socket.io.min.js"></script>
    <script>
        const socket = io({
            reconnection: true,
            reconnectionAttempts: 10,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            timeout: 20000
        });
        const chatArea = document.getElementById('chat-area');
        const textInput = document.getElementById('text-input');
        const micBtn = document.getElementById('mic-btn');
        const typingEl = document.getElementById('typing');
        const statusEl = document.getElementById('status');

        // ============================================================
        // CONNECTION: Reconnection & error handling
        // ============================================================
        let isConnected = false;

        socket.on('connect', () => {
            isConnected = true;
            statusEl.textContent = 'Connected â€” choose a mode to start';
            statusEl.style.color = '#666';
        });

        socket.on('disconnect', (reason) => {
            isConnected = false;
            typingEl.style.display = 'none';
            statusEl.textContent = 'Disconnected â€” reconnecting...';
            statusEl.style.color = '#dc3545';
            if (reason === 'io server disconnect') {
                socket.connect(); // Server disconnected us, reconnect manually
            }
        });

        socket.on('reconnect', (attemptNumber) => {
            isConnected = true;
            statusEl.textContent = 'Reconnected! You may need to restart your session.';
            statusEl.style.color = '#28a745';
            setTimeout(() => { statusEl.style.color = '#666'; }, 3000);
        });

        socket.on('reconnect_attempt', (attemptNumber) => {
            statusEl.textContent = `Reconnecting... (attempt ${attemptNumber})`;
        });

        socket.on('reconnect_failed', () => {
            statusEl.textContent = 'Connection lost. Please refresh the page.';
            statusEl.style.color = '#dc3545';
        });

        socket.on('connect_error', (err) => {
            statusEl.textContent = 'Connection error â€” retrying...';
            statusEl.style.color = '#dc3545';
        });

        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let currentAudio = null;  // Track currently playing audio
        let botIsPlaying = false; // True while bot audio is playing

        // ============================================================
        // COST OPTIMIZATION: Voice mode state
        // ============================================================
        let voiceModeOn = false;   // Text-first by default
        let sessionStartTime = Date.now();
        let sessionTimerInterval = null;
        let pendingTtsMessages = {};  // {msg_id: element} for on-demand TTS

        // SECURITY: Escape HTML to prevent XSS
        function escapeHTML(str) {
            const div = document.createElement('div');
            div.appendChild(document.createTextNode(str));
            return div.innerHTML;
        }

        // --- Session Timer ---
        function startSessionTimer() {
            sessionStartTime = Date.now();
            if (sessionTimerInterval) clearInterval(sessionTimerInterval);
            sessionTimerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - sessionStartTime) / 1000);
                const mins = String(Math.floor(elapsed / 60)).padStart(2, '0');
                const secs = String(elapsed % 60).padStart(2, '0');
                document.getElementById('session-timer').textContent = `${mins}:${secs}`;
            }, 1000);
        }

        // --- Voice Mode Toggle ---
        function toggleVoiceMode() {
            const toggle = document.getElementById('voice-toggle');
            voiceModeOn = toggle.checked;
            socket.emit('toggle_voice_mode', { voice_mode: voiceModeOn });

            const label = document.getElementById('voice-mode-label');
            const badge = document.getElementById('cost-badge');
            if (voiceModeOn) {
                label.textContent = 'Voice mode';
                badge.textContent = 'auto-TTS on';
                badge.className = 'cost-badge active';
                // Auto-start listening when voice mode is turned on
                if (!isRecording) {
                    autoListenEnabled = true;
                    setTimeout(() => startListening(), 200);
                }
            } else {
                label.textContent = 'Text mode';
                badge.textContent = '$$$ saving';
                badge.className = 'cost-badge saving';
                // Stop listening when voice mode is turned off
                autoListenEnabled = false;
                if (isRecording) {
                    stopVAD();
                    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                        mediaRecorder.stop();
                    }
                    isRecording = false;
                    micBtn.classList.remove('recording');
                }
                statusEl.textContent = 'Text mode â€” type your message below.';
            }
        }

        // --- VAD (Voice Activity Detection) ---
        let audioContext = null;
        let analyser = null;
        let micStream = null;
        let vadInterval = null;
        let silenceStart = null;
        let speechDetected = false;
        let autoListenEnabled = false;  // true after first mic click
        let wasInterrupted = false; // Track if user interrupted bot
        const SILENCE_THRESHOLD = 25;   // RMS volume below this = silence (raised to ignore clicks/typing)
        const SILENCE_DURATION = 1500;  // ms of silence before auto-stop (1.5s wait after user stops)
        const VAD_CHECK_INTERVAL = 50;  // ms between VAD checks
        const INTERRUPT_SPEECH_MIN_MS = 400; // must speak at least this long during bot playback to count as interruption
        const MIN_SPEECH_DURATION_MS = 300; // minimum sustained speech to count as real speech (filters clicks/taps)
        let speechStartTime = null;     // when current speech burst started
        let interruptionDetectedAt = null; // timestamp when interruption was detected

        function getRMS(analyserNode) {
            const data = new Uint8Array(analyserNode.fftSize);
            analyserNode.getByteTimeDomainData(data);
            let sum = 0;
            for (let i = 0; i < data.length; i++) {
                const val = (data[i] - 128);
                sum += val * val;
            }
            return Math.sqrt(sum / data.length);
        }

        function startVAD() {
            if (!analyser) return;
            silenceStart = null;
            speechDetected = false;
            speechStartTime = null;
            interruptionDetectedAt = null;
            vadInterval = setInterval(() => {
                const rms = getRMS(analyser);
                if (rms > SILENCE_THRESHOLD) {
                    // Voice detected â€” set start time only once
                    if (!speechStartTime) {
                        speechStartTime = Date.now();
                    }
                    // Only mark as real speech after sustained sound (filters clicks/typing)
                    if (Date.now() - speechStartTime > MIN_SPEECH_DURATION_MS) {
                        speechDetected = true;
                    }
                    silenceStart = null;

                    // If bot is playing audio, only interrupt after sustained speech
                    if (botIsPlaying && speechStartTime && (Date.now() - speechStartTime > INTERRUPT_SPEECH_MIN_MS)) {
                        stopCurrentAudio();
                        wasInterrupted = true;
                        interruptionDetectedAt = Date.now();
                        // Discard all audio chunks recorded while bot was playing (contains bot's voice)
                        audioChunks = [];
                        statusEl.textContent = 'ðŸŽ¤ Go ahead, I\'m listening...';
                    } else if (!botIsPlaying) {
                        statusEl.textContent = 'ðŸŽ¤ Listening...';
                    }
                } else if (speechDetected) {
                    // Was speaking, now silent
                    if (!silenceStart) {
                        silenceStart = Date.now();
                    } else if (Date.now() - silenceStart > SILENCE_DURATION) {
                        // If we just interrupted, give extra time for user to continue speaking
                        if (interruptionDetectedAt && (Date.now() - interruptionDetectedAt < 3000)) {
                            // Within 3s of interruption â€” use longer silence window
                            if (Date.now() - silenceStart > 2000) {
                                stopRecordingAndSend();
                            }
                        } else {
                            stopRecordingAndSend();
                        }
                    }
                } else {
                    // Sound dropped below threshold before speech was confirmed
                    // Reset so brief noise spikes don't permanently set speechStartTime
                    speechStartTime = null;
                }
            }, VAD_CHECK_INTERVAL);
        }

        function stopVAD() {
            if (vadInterval) {
                clearInterval(vadInterval);
                vadInterval = null;
            }
        }

        // Stop any currently playing bot audio
        function stopCurrentAudio() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            botIsPlaying = false;
        }

        // --- Socket events ---
        socket.on('audio_response', (data) => {
            typingEl.style.display = 'none';
            // Stop any previous audio first
            stopCurrentAudio();

            // Play audio
            const audioBytes = Uint8Array.from(atob(data.audio), c => c.charCodeAt(0));
            const blob = new Blob([audioBytes], { type: 'audio/ogg; codecs=opus' });
            const url = URL.createObjectURL(blob);

            // Add bot message with audio player
            addBotMessage(data.text, url);

            // Auto-play and track
            currentAudio = new Audio(url);
            botIsPlaying = true;
            currentAudio.onended = () => {
                currentAudio = null;
                botIsPlaying = false;
                // Auto-listen after bot finishes speaking in voice mode
                if ((voiceModeOn || autoListenEnabled) && !isRecording) {
                    setTimeout(() => startListening(), 200);
                }
            };
            currentAudio.play().catch(e => {
                console.log('Autoplay blocked:', e);
                botIsPlaying = false;
            });

            // Start listening immediately while bot is speaking (for interruption detection)
            if ((voiceModeOn || autoListenEnabled) && !isRecording) {
                setTimeout(() => startListening(true), 200);
            }
        });

        // COST OPTIMIZATION: Text-only response with on-demand play button
        socket.on('text_response', (data) => {
            typingEl.style.display = 'none';
            addBotMessageWithPlayBtn(data.text, data.msg_id);
            // In voice mode, auto-start listening after receiving text response
            if (voiceModeOn && !isRecording && !botIsPlaying) {
                setTimeout(() => startListening(), 300);
            }
        });

        // COST OPTIMIZATION: On-demand TTS audio received
        socket.on('tts_audio', (data) => {
            const msgId = data.msg_id;
            const audioBytes = Uint8Array.from(atob(data.audio), c => c.charCodeAt(0));
            const blob = new Blob([audioBytes], { type: 'audio/ogg; codecs=opus' });
            const url = URL.createObjectURL(blob);

            // Update the play button to show audio player
            const container = pendingTtsMessages[msgId];
            if (container) {
                const audioDiv = container.querySelector('.tts-play-area');
                if (audioDiv) {
                    audioDiv.innerHTML = `<audio controls autoplay src="${url}" style="height:32px;width:100%;margin-top:5px;"></audio>`;
                }
                delete pendingTtsMessages[msgId];
            }

            // Also play it
            stopCurrentAudio();
            currentAudio = new Audio(url);
            botIsPlaying = true;
            currentAudio.onended = () => {
                currentAudio = null;
                botIsPlaying = false;
            };
            currentAudio.play().catch(() => { botIsPlaying = false; });
        });

        socket.on('voice_mode_changed', (data) => {
            statusEl.textContent = data.message;
        });

        socket.on('status', (data) => {
            typingEl.style.display = 'none';
            statusEl.textContent = data.message;
        });

        // --- UI functions ---
        function addBotMessage(text, audioUrl) {
            const div = document.createElement('div');
            div.className = 'message bot';
            // SECURITY: Escape text to prevent XSS
            const safeText = escapeHTML(text);
            div.innerHTML = `
                <div class="avatar"><i class="fas fa-robot"></i></div>
                <div>
                    <div class="bubble">${safeText}</div>
                    ${audioUrl ? `<div class="audio-player"><audio controls src="${audioUrl}"></audio></div>` : ''}
                </div>`;
            chatArea.appendChild(div);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        function addUserMessage(text) {
            const div = document.createElement('div');
            div.className = 'message user';
            // SECURITY: Escape text to prevent XSS
            const safeText = escapeHTML(text);
            div.innerHTML = `
                <div class="bubble">${safeText}</div>
                <div class="avatar"><i class="fas fa-user"></i></div>`;
            chatArea.appendChild(div);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        // COST OPTIMIZATION: Bot message with on-demand play button (no auto TTS)
        function addBotMessageWithPlayBtn(text, msgId) {
            const div = document.createElement('div');
            div.className = 'message bot';
            const safeText = escapeHTML(text);
            const encodedText = btoa(encodeURIComponent(text));
            div.innerHTML = `
                <div class="avatar"><i class="fas fa-robot"></i></div>
                <div>
                    <div class="bubble">${safeText}</div>
                    <div class="tts-play-area">
                        <button class="play-tts-btn" data-msgid="${msgId}" data-encoded="${encodedText}">
                            <i class="fas fa-volume-up"></i> Play audio
                        </button>
                    </div>
                </div>`;
            // Attach click handler safely (avoids inline JS injection)
            const playBtn = div.querySelector('.play-tts-btn');
            playBtn.addEventListener('click', function() {
                requestTTS(this, msgId, encodedText);
            });
            chatArea.appendChild(div);
            chatArea.scrollTop = chatArea.scrollHeight;
            // Store reference for when TTS comes back
            pendingTtsMessages[msgId] = div;
        }

        // Request on-demand TTS for a specific message
        function requestTTS(btn, msgId, encodedText) {
            const text = decodeURIComponent(atob(encodedText));
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';
            socket.emit('request_tts', { text: text, msg_id: msgId });
        }

        function showThinking() {
            typingEl.style.display = 'block';
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        // --- Mode selection ---
        function startInterview() {
            chatArea.innerHTML = '';
            statusEl.textContent = 'Interview Assistant';
            startSessionTimer();
            showThinking();
            socket.emit('start_interview');
        }

        function startHelpdesk() {
            chatArea.innerHTML = '';
            statusEl.textContent = 'IT Helpdesk';
            startSessionTimer();
            showThinking();
            socket.emit('start_helpdesk');
        }

        function showLanguagePicker() {
            document.getElementById('language-picker').style.display = 'block';
        }

        function startLanguageTest() {
            const lang = document.getElementById('lang-select').value;
            document.getElementById('language-picker').style.display = 'none';
            chatArea.innerHTML = '';
            statusEl.textContent = 'Language Practice Companion';
            startSessionTimer();
            showThinking();
            socket.emit('start_language_test', { language: lang });
        }

        function resetSession() {
            stopCurrentAudio();  // Stop any playing audio
            stopVAD();
            if (isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                micBtn.classList.remove('recording');
            }
            releaseMicStream();  // Fully release mic on reset
            autoListenEnabled = false;
            voiceModeOn = false;
            document.getElementById('voice-toggle').checked = false;
            document.getElementById('voice-mode-label').textContent = 'Text mode';
            document.getElementById('cost-badge').textContent = '$$$ saving';
            document.getElementById('cost-badge').className = 'cost-badge saving';
            if (sessionTimerInterval) clearInterval(sessionTimerInterval);
            document.getElementById('session-timer').textContent = '00:00';
            pendingTtsMessages = {};
            chatArea.innerHTML = '';
            document.getElementById('language-picker').style.display = 'none';
            socket.emit('reset');
        }

        // --- Text input ---
        function sendText() {
            if (!isConnected) {
                statusEl.textContent = 'Not connected â€” please wait...';
                return;
            }
            let text = textInput.value.trim();
            if (!text) return;
            // SECURITY: Client-side length limit
            if (text.length > 2000) {
                text = text.substring(0, 2000);
                statusEl.textContent = 'Message trimmed to 2000 characters.';
            }
            stopCurrentAudio();  // Interrupt bot if speaking
            addUserMessage(text);
            textInput.value = '';
            showThinking();
            socket.emit('text_message', { text: text });
        }

        // --- Audio recording with Voice Activity Detection ---
        async function startListening(duringBotPlayback = false) {
            if (isRecording) return;
            // Only stop bot audio if user explicitly initiated (not during passive listening)
            if (!duringBotPlayback) {
                stopCurrentAudio();
            }

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                statusEl.textContent = 'Browser does not support audio recording';
                return;
            }
            try {
                micStream = await navigator.mediaDevices.getUserMedia({
                    audio: { echoCancellation: true, noiseSuppression: true }
                });

                // Set up Web Audio API for VAD
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(micStream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);

                // Set up MediaRecorder
                const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
                    ? 'audio/webm;codecs=opus' : 'audio/webm';
                mediaRecorder = new MediaRecorder(micStream, { mimeType });
                audioChunks = [];

                mediaRecorder.ondataavailable = e => {
                    if (e.data.size > 0) audioChunks.push(e.data);
                };

                mediaRecorder.onstop = () => {
                    stopVAD();
                    const blob = new Blob(audioChunks, { type: mimeType });
                    // Only send if we actually detected meaningful speech
                    if (speechDetected && blob.size > 2000) {
                        const reader = new FileReader();
                        reader.onload = () => {
                            const b64 = btoa(
                                new Uint8Array(reader.result)
                                    .reduce((data, byte) => data + String.fromCharCode(byte), '')
                            );
                            addUserMessage('ðŸŽ¤ [Voice message]');
                            showThinking();
                            socket.emit('audio_message', { audio: b64, mimeType: mimeType, interrupted: wasInterrupted });
                            wasInterrupted = false;
                        };
                        reader.readAsArrayBuffer(blob);
                        // Auto re-listen after sending (will start once bot finishes speaking)
                        // A short delay lets the socket emit complete first
                    } else {
                        // No speech detected â€” keep listening if voice mode is on
                        if (voiceModeOn) {
                            if (!botIsPlaying) {
                                statusEl.textContent = 'ðŸŽ¤ Waiting for you to speak...';
                                setTimeout(() => startListening(), 200);
                            }
                        } else if (autoListenEnabled) {
                            if (!botIsPlaying) {
                                statusEl.textContent = 'ðŸŽ¤ Waiting for you to speak...';
                                setTimeout(() => startListening(), 200);
                            }
                        } else {
                            statusEl.textContent = 'No speech detected. Tap mic to try again.';
                        }
                    }
                    // Clean up mic stream
                    if (micStream) {
                        micStream.getTracks().forEach(t => t.stop());
                        micStream = null;
                    }
                    if (audioContext) {
                        audioContext.close();
                        audioContext = null;
                        analyser = null;
                    }
                };

                mediaRecorder.start(250);
                isRecording = true;
                autoListenEnabled = true;
                micBtn.classList.add('recording');
                statusEl.textContent = 'ðŸŽ¤ Listening... (speak, I\'ll detect when you stop)';

                // Start voice activity detection
                startVAD();

            } catch (err) {
                if (err.name === 'NotFoundError') {
                    statusEl.textContent = 'No microphone found. Please connect one.';
                } else if (err.name === 'NotAllowedError') {
                    statusEl.textContent = 'Microphone permission denied. Allow it in browser settings.';
                } else {
                    statusEl.textContent = 'Mic error: ' + err.message;
                }
            }
        }

        function stopRecordingAndSend() {
            if (!isRecording || !mediaRecorder) return;
            mediaRecorder.stop();
            isRecording = false;
            micBtn.classList.remove('recording');
            statusEl.textContent = 'Processing audio...';
        }

        // Toggle: click mic to start, click again to force-stop, or VAD auto-stops
        async function toggleRecording() {
            if (!isRecording) {
                await startListening();
            } else {
                // Manual stop (force-stop override)
                stopRecordingAndSend();
            }
        }

        // --- PWA: Register Service Worker ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js', { scope: '/' })
                    .then((reg) => console.log('[PWA] Service Worker registered, scope:', reg.scope))
                    .catch((err) => console.log('[PWA] SW registration failed:', err));
            });
        }
    </script>
</body>
</html>